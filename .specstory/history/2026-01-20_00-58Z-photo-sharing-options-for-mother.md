<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 5af8ec14-6e76-420b-9e8f-e687dbc305dd (2026-01-20 00:58Z) -->

# Photo sharing options for mother (2026-01-20 00:58Z)

_**User**_

i need to add a docs dir to this project. one new doc i need added needs to document some options for sending and recieving phtos to and from my mother. i've done some research and want to capture the options i have found:
Decision Matrix
SolutionSender FrictionReliability TodaySelf-HostedSetup ComplexityGoogle PhotosZeroHighNoLowPhotoSync + PhotoPrismZero (trigger-based)HighYesModerateImmich (current)Low-Medium (open app occasionally)MediumYesModerateImmich (post-PhotoKit)ZeroHigh (expected)YesModerate
Analysis
The iOS constraint changes the calculus. Until PhotoKit API ships (Q1-Q2 2026 estimate), all self-hosted solutions have the same fundamental iOS limitation. The differentiator is workaround quality.
PhotoSync's trigger approach is clever:

Geofence trigger = "uploads when mom connects to her home WiFi"
Charge trigger = "uploads when phone is plugged in at night"
Both are invisible to her after setup—zero cognitive load

Immich's current state requires periodic app opening. For a non-technical user, "open this app sometimes or your photos won't back up" is friction that will fail silently.
My Recommendation: Tiered Approach
Option A: Lowest friction, not self-hosted
Google Photos shared account. Zero friction, HEIC quality loophole, you already validated it works.
Option B: Self-hosted, reliable today
PhotoSync ($5-10) → PhotoPrism on your homelab via Tailscale. You deploy PhotoPrism, configure her phone once with WiFi geofence trigger, done. She never thinks about it.
Option C: Self-hosted, best long-term
Immich now, accept current iOS limitations, upgrade experience when PhotoKit ships. Risk: mom's photos may have multi-hour delays until then.
Trade-off table:
FactorGoogle PhotosPhotoSync+PhotoPrismImmichSelf-hosted❌✅✅Zero friction today✅✅❌No paid apps✅❌ ($5-10)✅Future-proofMediumMediumHighYour maintenanceNonePhotoPrism updatesImmich updates
Given your stated preference for simplicity over architectural consistency, Google Photos is still the pragmatic winner—unless self-hosting is a hard requirement for privacy/principle reasons.
If self-hosting matters: PhotoSync + PhotoPrism is the reliable path today. Immich is the better long-term bet but has friction until PhotoKit ships.

---

_**Agent (model composer-1, mode Agent)**_


Creating a `docs` directory and adding a document with your photo-sharing options research.


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/README.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="list_dir_v2">
<details>
<summary>Tool use: **list_dir_v2**</summary>


Parameters:

```json
{
  "targetDirectory": "/Users/basher8383/dev/personal/Hallowbranch-Restore"
}
```
Result:

```json
{
  "directoryTreeRoot": {
    "absPath": "/Users/basher8383/dev/personal/Hallowbranch-Restore",
    "childrenDirs": [
      {
        "absPath": "/Users/basher8383/dev/personal/Hallowbranch-Restore/.specstory",
        "childrenFiles": [
          {
            "name": ".gitignore"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "/Users/basher8383/dev/personal/Hallowbranch-Restore/components",
        "childrenFiles": [
          {
            "name": "BeforeAfterView.tsx"
          },
          {
            "name": "EnhancementControls.tsx"
          },
          {
            "name": "Header.tsx"
          },
          {
            "name": "ImageUpload.tsx"
          },
          {
            "name": "RefinePanel.tsx"
          },
          {
            "name": "ResultActions.tsx"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "/Users/basher8383/dev/personal/Hallowbranch-Restore/context",
        "childrenFiles": [
          {
            "name": "AppContext.tsx"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "/Users/basher8383/dev/personal/Hallowbranch-Restore/services",
        "childrenFiles": [
          {
            "name": "geminiService.ts"
          }
        ],
        "childrenWereProcessed": true
      }
    ],
    "childrenFiles": [
      {
        "name": ".gitignore"
      },
      {
        "name": "App.tsx"
      },
      {
        "name": "constants.ts"
      },
      {
        "name": "index.html"
      },
      {
        "name": "index.tsx"
      },
      {
        "name": "metadata.json"
      },
      {
        "name": "package.json"
      },
      {
        "name": "README.md"
      },
      {
        "name": "renovate.json"
      },
      {
        "name": "tsconfig.json"
      },
      {
        "name": "types.ts"
      },
      {
        "name": "vite.config.ts"
      }
    ],
    "childrenWereProcessed": true
  }
}
```
Status: **completed**


</details>
</tool-use>

---


Creating the `docs` directory and adding the photo-sharing options document:


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/photo-sharing-options.md</summary>

</details>

</tool-use>

---


Created the `docs` directory and added `photo-sharing-options.md` with your research. The document includes:

- Decision matrix comparing all solutions
- Analysis of iOS constraints and workarounds
- Three-tier recommendation (Options A, B, C)
- Trade-off table
- Conclusion with recommendations

The document is formatted in Markdown with tables and clear sections. You can find it at `docs/photo-sharing-options.md`.

---

_**User**_

The next doc or set of docs i need is to capture "how" I built this repo. I built this repo with a multiphased approach starting with leveraging perplexity to research and refine my requirements. I then leveraged Opus 4.5 to help brainstorm and come up with my refined requirements and spec for the intended end state. My requirement for where to build this project was to specifically leverage Google AI studio's build function. I then worked with Opus to craft research prompts targeted at gaining an understanding of how Google AI studio prompt worked and community best practices for effecitve prompting. Once i had those perplexity results I worked with Opus to actually craft the targerted prompts. Then i started a new build project in google AI studio and used the prompt strategy opus provided.

other than this path to how i got here i also want to document the prompts i used. help me properly structure documentaion for this

---

_**Agent (model composer-1, mode Agent)**_


Reviewing key project files to understand the project, then creating structured documentation for the build process and prompts.


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/README.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/App.tsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/package.json</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/metadata.json</summary>

</details>
</tool-use>

---


Creating structured documentation: a build process doc and a prompts doc.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/build-process.md</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/README.md</summary>

</details>

</tool-use>

---


Created a documentation structure for your build process:

## Created Files

1. **`docs/build-process.md`** — Documents your multiphased methodology:
   - Phase 1: Requirements Research & Refinement
   - Phase 2: Prompt Strategy Research
   - Phase 3: Implementation
   - Process flow diagram
   - Tools used and lessons learned

2. **`docs/prompts.md`** — Template for documenting your prompts:
   - Organized by phase
   - Sections for Perplexity research prompts
   - Sections for Opus refinement prompts
   - Sections for Google AI Studio build prompts
   - Includes placeholders with examples

3. **`docs/README.md`** — Index linking all documentation

The structure is ready. Fill in the actual prompts in `prompts.md` using the provided sections and placeholders. The build process document captures your methodology; add your specific prompts to complete the documentation.

---

_**User**_

alright, let me give you the actual prompts used in google AI studio first. There was a primary prompt with two targeted follow-ups and a system instructions prompt used. Heres the main prompt: Create a family photo restoration web app using React and TypeScript
that integrates with Gemini 3 Pro Image for AI-powered restoration.
App Purpose
Restore old family photographs (black & white and color) by removing
damage, colorizing, and enhancing clarity while preserving facial
identity and historical authenticity.
Core User Flow
Upload → Select restoration options → Process with Gemini →
Compare before/after → Refine iteratively → Download result
Required Components
ImageUpload
Drag-and-drop or button file selection
Accept PNG and JPEG only (validate on select)
Max file size: 7MB (AI Studio limit)
Show local preview using URL.createObjectURL before processing
Display helper text: "For best results, scan at 600+ DPI. Avoid
heavy preprocessing—the AI works best with original scans."
EnhancementControls
Two modes: Global restore and Local repair
Global restore options:
Photo type selector: "Old B&W", "Faded color", "Modern photo"
Damage types (multi-select checkboxes): Scratches, Tears, Fading,
Stains, Cracks
Restoration intensity: Light / Moderate / Aggressive (radio buttons)
Colorize toggle (only enabled when "Old B&W" selected)
Preserve grain toggle
Face preservation level: Strict / Moderate / Flexible (default: Strict)
Local repair mode:
Simple rectangle selection tool over the image
Repair type dropdown: Fix damage, Reduce noise, Colorize area
Optional text field: "Specific instructions for this area"
BeforeAfterView
Side-by-side or draggable slider comparison
Clear labels: "Original Scan" and "Restored"
Zoom controls with presets: "Fit", "100%", "Zoom to face"
Pan capability when zoomed
RefinePanel
"Refine with AI" button for follow-up adjustments
Text input for refinement instructions
Shows refinement history within session
"Start over from original" button
ResultActions
Download restored image (PNG)
Download comparison image (side-by-side PNG)
Session gallery showing all restorations in current session
Gemini Integration Architecture
geminiService.ts
Build a prompt generator that maps UI controls to restoration prompts.
System instruction (set once per session):
You are a professional photo restoration specialist. Your role is to
repair and enhance damaged family photographs while maintaining absolute
fidelity to the original subjects' identities, expressions, and
historical authenticity.
Core principles:
Preserve facial features exactly as shown in the original
Maintain historical era characteristics and visual style
Apply natural, period-appropriate colors when colorizing
Reconstruct damaged areas using only visible context clues
If features are completely missing, leave subtle blur rather than
inventing details
Prompt template structure:
Map damage type checkboxes to specific repair instructions
Map intensity level to restoration approach language
Map face preservation level to constraint specificity
Always use positive constraints ("preserve exactly") never negative
("do not alter")
For local repairs, include region coordinates and scope limitation
Example generated prompt for moderate B&W restoration with scratches:
Perform moderate restoration of this historical black-and-white
photograph.
Damage repair: Remove all visible scratches and fine lines. Restore
faded areas to their original tonal range.
Face handling: Preserve facial features, expressions, and proportions
with absolute fidelity. Maintain exact eye color, nose shape, mouth
structure, and facial contours.
Colorize this black-and-white image with natural, period-appropriate
colors. Ensure skin tones are realistic and clothing colors match the
historical era.
Preserve the original film grain and texture characteristics.
Restoration approach: Balance restoration quality with historical
authenticity.
Multi-turn conversation support
Use Gemini chat session (startChat) for iterative refinement
Maintain session state so follow-up prompts reference previous output
Include "reference the original uploaded photograph" in refinement
prompts to prevent identity drift
Limit to 5 refinement turns before prompting user to restart from
original
Technical Requirements
React functional components with TypeScript
Tailwind CSS for styling
Use @google/generative-ai SDK for Gemini integration
Model: gemini-3-pro-image-preview
Response modalities: ['TEXT', 'IMAGE']
Image output size: 2K
State management: React Context for restoration parameters and
session history
Error handling: Network timeouts, invalid formats, file size
exceeded, API rate limits with user-friendly messages
UI Style
Clean, minimal interface
Dark mode default with light mode toggle
Primary color: Indigo (#4F46E5)
Card-based layout for controls and preview
Responsive: Works on desktop and tablet
Generate the complete application with all components, the Gemini
service layer with prompt builder, and proper TypeScript types.

---

_**Agent (model composer-1, mode Agent)**_


Adding the main prompt to `prompts.md`. Reviewing the file structure, then updating it.


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>
</tool-use>

---


Updating `prompts.md` with the main prompt and adding sections for system instructions and follow-up prompts:


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>

</tool-use>

---


Added the main build prompt to `prompts.md`. It's documented in the "Phase 3: Implementation" section.

I've also added placeholders for:
- **System Instructions Prompt** — separate section
- **Follow-up Prompts** — section for the two targeted follow-ups

Share the system instructions prompt and the two follow-up prompts, and I'll add them to the document.

---

_**User**_

i fixed most of the formatting for the prompt, pls review to ensure it is consistant

---

_**Agent (model composer-1, mode Agent)**_


Reviewing the formatted prompt for consistency:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>
</tool-use>

---


Fixing formatting inconsistencies:


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>

</tool-use>

---


Made formatting consistent:

1. **EnhancementControls section**: Made "Two modes" a bullet point and bolded "Global restore options:" and "Local repair mode:" for consistency
2. **System instruction**: Wrapped the instruction text in a code block
3. **Section labels**: Bolded "Core principles:", "Prompt template structure:", and "Example generated prompt:" for consistency
4. **Example prompt**: Wrapped the example prompt in a code block

The document now uses consistent formatting: bold labels for subsections, bullet points for lists, and code blocks for actual prompt/instruction text.

---

_**User**_

great, looking back at my notes i see i actually had 3 follow up prompts:

After initial generation, use these follow-up prompts for iteration:
Add local edit tool:

The RegionSelector needs implementation. Add a rectangular selection 
overlay that appears when "Local repair mode" is active. Store 
selection as {x, y, width, height} relative to image dimensions. 
Pass these coordinates to the prompt builder.

Refine prompt builder:

In geminiService.ts, the buildPrompt function needs the full 
parameterization. Add the damage type mapping, intensity mapping, 
and face preservation mapping as shown in the requirements. Export 
TypeScript types for RestorationConfig.

Handle edge cases:

Add comprehensive error handling for:
- Network timeouts during API calls (show retry button)
- Files exceeding 7MB (show size and recommendation to resize)
- API rate limit responses (implement exponential backoff, show 
  wait time to user)
- Session expiry (prompt to start new session)

---

_**Agent (model composer-1, mode Agent)**_


Adding the three follow-up prompts to the document:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>

</tool-use>

---


Added all three follow-up prompts to the document. They're formatted consistently with the rest of the prompts and include:

1. **Add Local Edit Tool** — RegionSelector implementation
2. **Refine Prompt Builder** — Complete parameterization of buildPrompt function
3. **Handle Edge Cases** — Comprehensive error handling

Each prompt includes its purpose and expected result. The documentation now captures the complete prompt sequence used in the build process.

---

_**User**_

System instructions for Google AI studio:

You are building a family photo restoration app. All generated code must:

Code standards:
- React functional components with TypeScript
- Tailwind CSS for styling
- Proper error handling with user-friendly messages
- No hardcoded API keys—use environment variables

Gemini integration standards:
- Model: gemini-3-pro-image-preview
- Response modalities: ['TEXT', 'IMAGE']
- Use @google/generative-ai SDK
- Use chat sessions (startChat) for multi-turn refinement

Photo restoration principles (embed in generated prompt logic):
- Preserve facial features exactly as shown in originals
- Use positive constraints ("preserve exactly") not negative ("do not alter")
- Reconstruct damaged areas using only visible context clues
- If features are completely missing, leave subtle blur rather than invent
- Apply natural, period-appropriate colors when colorizing

---

_**Agent (model composer-1, mode Agent)**_


Adding the system instructions prompt to the document:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>

</tool-use>

---


Added the system instructions prompt to the document. It's formatted consistently with the other prompts and includes:

- **Code standards** — React/TypeScript, Tailwind, error handling, environment variables
- **Gemini integration standards** — Model, response modalities, SDK usage, chat sessions
- **Photo restoration principles** — Facial preservation, constraint language, reconstruction guidelines

The documentation now includes all prompts used in the Google AI Studio build process: the main build prompt, system instructions, and the three follow-up prompts.

---

_**User**_

Perplexity Research Prompt:
```text
What are the best practices for using Google AI Studio chat interface 
to iteratively build and prototype web applications?

Context: Using AI Studio as a development assistant (similar to Claude 
or ChatGPT for coding) rather than as an API endpoint. Goal is to 
generate React/Next.js components, API routes, and prompt templates 
through conversational iteration.

Research:
1. Code generation capabilities: How does Gemini in AI Studio compare 
   to Claude/GPT-4 for full-stack web app development?
2. Session management: Best practices for maintaining context across 
   a long development session (file structure, component relationships)
3. Prompt patterns: How to structure requests for component generation, 
   refactoring, and iterative refinement
4. Artifact handling: Can AI Studio preview/render generated code, 
   or is it text-only output?
5. Limitations: Known gaps for development workflows compared to 
   dedicated coding assistants

Include experiences from developers using AI Studio for app prototyping, 
not just API integration tutorials.
```

Mode: Pro Search
This should surface whether AI Studio is viable for your workflow or if you'd be better served using Claude/Cursor with the Gemini research as input.

---

_**Agent (model composer-1, mode Agent)**_


Adding the Perplexity research prompt to the appropriate section:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>

</tool-use>

---


Added the Perplexity research prompt to the "Phase 2: Prompt Strategy Research" section. It includes:

- The full prompt text with context and research questions
- The "Pro Search" mode notation
- Purpose statement
- A placeholder for key findings (you can fill this in with the results)

The prompt is now documented alongside the other research prompts used in the build process.

---

_**User**_

Two phased research prompts and reasoning:

Phase 1: Domain Discovery (Broad)
```text
What are the current best practices in 2024-2025 for digitizing and 
preparing old family photographs before AI-based restoration?

Cover the full pipeline from physical photo to AI-ready input:
- Scanning vs phone capture trade-offs
- Preprocessing steps (dust removal, cropping, exposure correction)
- Whether preprocessing should happen before or after AI enhancement
- Common mistakes that degrade AI restoration quality

Include both professional archival workflows and consumer/hobbyist approaches.
For each stage, note: whether it's essential vs optional, and whether 
it's typically done manually, with traditional software, or delegated to AI.
```
Mode: Pro Search (sufficient depth, fast iteration)

Phase 2: Model-Specific (Targeted)
Run after Phase 1 establishes the landscape:
```text
For Google's Gemini image generation/editing models (specifically 
gemini-3-pro-image-preview or Imagen 3), what input preparation 
produces the best restoration results?

Evaluate:
1. Does the model perform better with raw scans or pre-cleaned images?
2. Are there resolution, format, or quality thresholds in documentation?
3. What preprocessing does the model handle internally vs expect externally?
4. Community experiences with family photo restoration specifically.

Search: Google AI documentation, AI Studio guides, developer forums, 
Reddit r/GoogleGeminiAI, r/photorestoration.
```

---

_**Agent (model composer-1, mode Agent)**_


Adding the two phased research prompts to Phase 1:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>

</tool-use>

---


Added both phased research prompts to Phase 1. The documentation now includes:

1. **Phase 1: Domain Discovery (Broad)** — General best practices for digitizing and preparing photos
2. **Phase 2: Model-Specific (Targeted)** — Gemini-specific input requirements and community experiences

Each prompt includes:
- The full prompt text
- Mode (Pro Search)
- Purpose
- Reasoning for the phased approach
- Placeholders for key findings

The structure shows the progression from broad domain research to targeted model-specific investigation, which informed the requirements refinement process.

---

_**User**_

ah, correction to the phase 2 gemini:

Solid Phase 1 results. Key takeaway: minimal preprocessing, high-resolution scan, let AI see the damage.
The gap: Phase 1 references GFPGAN/Real-ESRGAN but not Gemini. Need to validate whether Gemini follows the same "raw scan preferred" pattern or has different requirements.

Phase 2: Gemini-Specific
For Google's Gemini image generation/editing models in AI Studio 
(specifically gemini-2.0-flash-preview-image-generation or 
gemini-3-pro-image-preview), what input characteristics produce 
the best photo restoration results?

Evaluate:
1. Resolution requirements: min/max dimensions, DPI handling, file size limits
2. Format preferences: JPEG vs PNG vs TIFF for input
3. Does the model prefer raw degraded scans or pre-cleaned images?
4. Prompt engineering patterns for restoration tasks (scratch removal, 
   colorization, face preservation)
5. Known limitations for family photo restoration use cases

Search: Google AI documentation (ai.google.dev), AI Studio guides, 
Gemini API reference, developer forums, Reddit communities 
(r/GoogleGeminiAI, r/photorestoration, r/StableDiffusion for 
comparative context).

If documentation gaps exist for restoration-specific workflows, 
indicate what's undocumented vs confirmed.
Mode: Pro Search
This should clarify whether your app needs client-side preprocessing tools or can pass scans directly to Gemini. 

---

_**Agent (model composer-1, mode Agent)**_


Updating the Phase 2 Gemini-specific research prompt with the corrected version:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/prompts.md</summary>

</details>

</tool-use>

---


Updated the Phase 2 Gemini-specific research prompt with the corrected version. It now includes:

- **Context from Phase 1**: Notes the key takeaway (minimal preprocessing, high-resolution scan) and the gap (Phase 1 referenced other models but not Gemini)
- **Updated model names**: `gemini-2.0-flash-preview-image-generation` and `gemini-3-pro-image-preview`
- **More detailed evaluation points**: 5 specific areas including resolution, format, preprocessing preferences, prompt engineering, and limitations
- **More specific search sources**: Includes specific documentation sites and Reddit communities
- **Clearer purpose**: Focuses on determining whether client-side preprocessing is needed

The documentation now reflects the research strategy used to validate Gemini-specific requirements.

---

_**User**_

and then we can add this seperatly in here too:
# Prompt: Gemini Photo Restoration Templates

**Date:** 2026-01-12
**Confidence:** MEDIUM (community-sourced, validated through Perplexity research)

## Summary

Parameterized prompt templates for Gemini 3 Pro Image restoration workflows. Designed for programmatic generation from UI controls. Key principle: positive constraints only ("preserve exactly") never negative ("do not alter").

## System Instruction (Session-Level)

```
You are a professional photo restoration specialist. Your role is to 
repair and enhance damaged family photographs while maintaining absolute 
fidelity to the original subjects' identities, expressions, and 
historical authenticity.

Core principles:
- Preserve facial features exactly as shown in the original
- Maintain historical era characteristics and visual style
- Apply natural, period-appropriate colors when colorizing
- Reconstruct damaged areas using only visible context clues
- If features are completely missing, leave subtle blur rather than 
  inventing details
```

## Parameterized Restoration Prompt

### Input Parameters

```typescript
interface RestorationConfig {
  photoType: 'bw' | 'faded_color' | 'modern';
  damageTypes: ('scratches' | 'tears' | 'fading' | 'stains' | 'cracks')[];
  intensity: 'light' | 'moderate' | 'aggressive';
  colorize: boolean;
  preserveGrain: boolean;
  facePreservation: 'strict' | 'moderate' | 'flexible';
}
```

### Mapping Tables

**Damage type → instruction:**
| Type | Instruction |
|------|-------------|
| scratches | Remove all visible scratches and fine lines |
| tears | Repair torn and missing sections by reconstructing from surrounding context |
| fading | Restore faded areas to their original tonal range |
| stains | Eliminate discoloration, water marks, and chemical stains |
| cracks | Smooth over crack patterns while preserving underlying detail |

**Intensity → approach:**
| Level | Instruction |
|-------|-------------|
| light | Apply minimal corrections, preserving maximum originality |
| moderate | Balance restoration quality with historical authenticity |
| aggressive | Maximize clarity and detail recovery, prioritizing readability over perfect originality |

**Face preservation → constraint:**
| Level | Instruction |
|-------|-------------|
| strict | Preserve facial features, expressions, and proportions with absolute fidelity. Maintain exact eye color, nose shape, mouth structure, and facial contours. |
| moderate | Maintain core facial identity while allowing minor clarity improvements to features obscured by damage. |
| flexible | Improve facial clarity and definition while keeping recognizable likeness to the original subject. |

### Template

```
Perform {intensity} restoration of this historical photograph.

Damage repair: {joined damage instructions}.

Face handling: {face preservation instruction}

{if colorize}
Colorize this black-and-white image with natural, period-appropriate 
colors. Ensure skin tones are realistic and clothing colors match 
the historical era.
{else}
Maintain the original color scheme.
{/if}

{if preserveGrain}
Preserve the original film grain and texture characteristics.
{else}
Apply subtle smoothing to reduce excessive grain while maintaining 
natural texture.
{/if}

Restoration approach: {intensity instruction}

Output requirements: Return a high-resolution restored image that 
maintains the historical character and authenticity of the original 
photograph.
```

### Example Output

Config: `{ intensity: 'moderate', damageTypes: ['scratches', 'fading'], colorize: true, preserveGrain: true, facePreservation: 'strict' }`

```
Perform moderate restoration of this historical photograph.

Damage repair: Remove all visible scratches and fine lines. Restore 
faded areas to their original tonal range.

Face handling: Preserve facial features, expressions, and proportions 
with absolute fidelity. Maintain exact eye color, nose shape, mouth 
structure, and facial contours.

Colorize this black-and-white image with natural, period-appropriate 
colors. Ensure skin tones are realistic and clothing colors match 
the historical era.

Preserve the original film grain and texture characteristics.

Restoration approach: Balance restoration quality with historical 
authenticity.

Output requirements: Return a high-resolution restored image that 
maintains the historical character and authenticity of the original 
photograph.
```

## Local/Region Repair Prompt

```
Repair only the selected region of this photograph.

Region: {x}, {y}, {width}, {height} (relative coordinates)

Target only: {repair type - damage/noise/colorize}
{if specific instructions}
Specific instruction: {user text}
{/if}

Preserve unchanged: Everything outside the selected region.
Maintain consistency with surrounding areas at region boundaries.

Face handling (if region contains faces): {face preservation instruction}
```

## Multi-Turn Refinement Prompts

**Follow-up refinement:**
```
Refine the previous restoration. {user instruction}

Reference the original uploaded photograph for identity consistency.
Maintain all previous improvements while addressing this adjustment.
```

**Restart from original:**
```
Discard previous restoration attempts. Start fresh from the original 
uploaded photograph with these parameters:

{full restoration prompt}
```

## Anti-Patterns (Avoid)

❌ "Do not alter facial features" → ✅ "Preserve facial features exactly"
❌ "Don't smooth skin" → ✅ "Maintain natural skin texture and pore detail"
❌ "Do not change background" → ✅ "Keep background identical to original"
❌ Generic "restore this photo" → ✅ Specific damage types and constraints

## Model Requirements

- Model: `gemini-3-pro-image-preview`
- Input: PNG preferred (lossless), JPEG acceptable at 95%+ quality
- Resolution: 600+ DPI scans, under 7MB for AI Studio
- Output config: `response_modalities: ['TEXT', 'IMAGE']`, `image_size: '2K'`

## Known Limitations

- Face preservation is inconsistent even with optimal prompts (model limitation)
- Identity drift accumulates over 5+ refinement turns
- Over-smoothing occurs without explicit texture preservation language
- Safety filters may reject legitimate family photos (beach/pool settings)

---

_**Agent (model composer-1, mode Agent)**_


Creating a separate document for the Gemini Photo Restoration Templates:


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/gemini-restoration-templates.md</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/README.md</summary>

</details>
</tool-use>

---


Updating the docs README to include the new document:


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/basher8383/dev/personal/Hallowbranch-Restore/docs/README.md</summary>

</details>

</tool-use>

---


Created a new document `gemini-restoration-templates.md` with the Gemini Photo Restoration Templates. It includes:

- **System Instruction** (session-level)
- **Parameterized Restoration Prompt** with TypeScript interface and mapping tables
- **Local/Region Repair Prompt** template
- **Multi-Turn Refinement Prompts** for follow-ups and restarts
- **Anti-Patterns** to avoid
- **Model Requirements** and **Known Limitations**

Updated the docs README to include this new document. This serves as a reference for the prompt templates used in the application's `geminiService.ts` implementation.

---
